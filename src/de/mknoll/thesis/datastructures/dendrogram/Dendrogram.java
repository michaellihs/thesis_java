package de.mknoll.thesis.datastructures.dendrogram;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.Set;



/**
 * Class implements a dendrogram data structure
 * 
 * @author Michael Knoll <mimi@kaktusteam.de>
 */
public abstract class Dendrogram<T> {

	/**
	 * Holds parent of dendrogram
	 */
	private LinkDendrogram<T> parent;
	
	
	
	/**
	 * Holds reference link to most upper parent
	 */
	private Dendrogram<T> referenceLink;



	/**
	 * Holds id for Dendrogram (for debugging only!)
	 */
	protected String id;
	
	
	
	/**
	 * Constructor for dendrogram
	 */
	public Dendrogram() {
		this.referenceLink = this;
	}
	
	
	
	/**
	 * Constructor for dendrogram that takes an id (for debugging and development only)
	 * @param id
	 */
	public Dendrogram(String id) {
		this();
		this.id = id;
	}
	
	
	
	/**
	 * Returns parent dendrogram of this dendrogram
	 * 
	 * @return Parent dendrogram of this dendrogram
	 */
	public LinkDendrogram<T> parent() {
		return this.parent;
	}
	
	
	
	/**
	 * Returns true, if given element is contained in dendrogram
	 * 
	 * @param element
	 * @return
	 */
	public boolean contains(T element) {
		return this.memberSet().contains(element);
	}
	
	
	
	/**
	 * Returns true, if dendrogram is link
	 * 
	 * @return True, if dendrogram is link
	 */
	public boolean isLink() {
		return !this.isLeaf();
	}
	
	
	
	/**
	 * Returns true, if dendrogram is leaf
	 * 
	 * @return True, if dendrogram is leaf
	 */
	abstract public boolean isLeaf();
	


	/**
	 * Returns root of dendrogram
	 * 
	 * @return Most upper parent of dendrogram
	 */
	public Dendrogram<T> dereference() {
		Dendrogram<T> ancestor = this.referenceLink.parent();  
        if (ancestor == null) return this.referenceLink;  
        for (LinkDendrogram<T> nextAncestor = null;  
             (nextAncestor = ancestor.parent()) != null;  
             ancestor = nextAncestor);  
        this.referenceLink = ancestor;  
        return this.referenceLink; 
	}
	
	
	
	/**
	 * Returns number of contained objects
	 * 
	 * @return Number of contained objects
	 */
	public Integer size() {
		// TODO think about how to cache this!
		return this.memberSet().size();
	}
	
	
	
	/**
	 * Returns a partitioning of given size.
	 * 
	 * Partitioning a dendrogram is like cutting the dendrogram's tree
	 * at a certain level and gathering the membersets of the subtrees in
	 * a set.
	 * 
	 * @param Number of partitions to be created. Must be bigger than 1!
	 * @return Partitioning consisting of a set of membersets
	 * @throws IllegalArgumentException if number of partitions is less than 1
	 * @throws IllegalArgumentException if number of partitions is bigger than contained elements
	 */
	public Set<Set<T>> partition(Integer k) {
		Set<Dendrogram<T>> dendrograms = this.partitionDendrogram(k);
		Set<Set<T>> resultSet = new HashSet<Set<T>>(k);
		for(Dendrogram<T> d : dendrograms) {
			resultSet.add(d.memberSet());
		}
		return resultSet;
	}
	
	
	
	/**
	 * Returns a set of dendrograms with size k generated by "cutting" dendrogram
	 * such that k sub-dendrograms are generated.
	 * 
	 * @param Number of partitions to be created. Must be bigger than 1!
	 * @return Partitioning consisting of a set of membersets
	 * @throws IllegalArgumentException if number of partitions is less than 1
	 * @throws IllegalArgumentException if number of partitions is bigger than contained elements
	 */
	public Set<Dendrogram<T>> partitionDendrogram(Integer k) {
		if (k <= 1) {
			throw new IllegalArgumentException("Number of partitions must be bigger than 1!");
		}
		if (this.size() < k) {
			throw new IllegalArgumentException("This dendrograms only contains " + this.size() + " elements. You asked me to generate " + k + " partitions.");
		}
		
		// TODO original implementation has priority queue here, to select split with higher priority!
		LinkedList<Dendrogram<T>> queue = new LinkedList<Dendrogram<T>>();
		HashSet<Dendrogram<T>> resultSet = new HashSet<Dendrogram<T>>(k);
		
		queue.add(this);
		
		while(queue.size() + resultSet.size() < k) {
			Dendrogram<T> toSplit = queue.pop();
			toSplit.split(resultSet, queue);
		}
		
		for(Dendrogram<T> d : queue) {
			resultSet.add(d);
		}
		
		return resultSet;
	}
	
	
	
	/**
	 * Does a split on dendrogram. 
	 * 
	 * @param resultSet
	 * @param queue
	 */
	abstract void split(HashSet<Dendrogram<T>> resultSet, LinkedList<Dendrogram<T>> queue);
	
	
	
	/**
	 * Template method for getting member set of dendrogram
	 * 
	 * @return Members of dendrogram
	 */
	abstract public Set<T> memberSet();

	
	
	/**
	 * Template method for adding members of dendrogram to given set
	 * 
	 * @param Set to add members of dendrogram to
	 * @return Set of members
	 */
	abstract public void addMembers(Set<T> set);
	
	
	
	/**
	 * Sets parent to given dendrogram
	 * 
	 * @param Dendrogram to be set as parent
	 */
	protected void setParent(LinkDendrogram<T> parent) {
		this.parent = parent;
		this.referenceLink = parent;
	}
	
}
